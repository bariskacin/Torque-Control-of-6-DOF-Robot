#include "pm_std.h"
#include "ne_std.h"
#include "ssc_dae.h"
#include "pm_default_allocator.h"
#include "sm_ssci_NeDaePrivateData.h"
#include "sm_CTarget.h"
#define NULL_INDEX                     ((size_t) -1)
PmfMessageId sm_ssci_recordRunTimeError ( const char * errorId , const char *
errorMsg , NeuDiagnosticManager * mgr ) ;
#define pm_allocator_alloc(_allocator, _m, _n) ((_allocator)->mCallocFcn((_allocator), (_m), (_n)))
#define PM_ALLOCATE_ARRAY(_name, _type, _size, _allocator)\
 _name = (_type *) pm_allocator_alloc(_allocator, sizeof(_type), _size)
#define pm_size_to_int(_size)          ((int32_T) (_size))
extern const NeAssertData Robot_d319c82e_49_assertData [ ] ; extern const
NeZCData Robot_d319c82e_49_ZCData [ ] ; void
Robot_d319c82e_49_computeRuntimeParameters ( const double *
runtimeRootVariables , double * runtimeParameters ) ; void
Robot_d319c82e_49_validateRuntimeParameters ( const double *
runtimeParameters , int32_T * assertSatisfactionFlags ) ; void
Robot_d319c82e_49_computeAsmRuntimeDerivedValues ( const double *
runtimeParameters , RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle )
; void Robot_d319c82e_49_computeSimRuntimeDerivedValues ( const double *
runtimeParameters , RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle )
; void Robot_d319c82e_49_initializeGeometries ( const
RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle ) ; PmfMessageId
Robot_d319c82e_49_compDerivs ( const RuntimeDerivedValuesBundle * , const int
* , const double * , const int * , const double * , const double * , const
double * , const double * , double * , double * , NeuDiagnosticManager *
neDiagMgr ) ; PmfMessageId Robot_d319c82e_49_numJacPerturbLoBounds ( const
RuntimeDerivedValuesBundle * , const int * , const double * , const int * ,
const double * , const double * , const double * , const double * , double *
, double * , NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_numJacPerturbHiBounds ( const RuntimeDerivedValuesBundle *
, const int * , const double * , const int * , const double * , const double
* , const double * , const double * , double * , double * ,
NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_checkDynamics ( const RuntimeDerivedValuesBundle * , const
double * , const double * , const double * , const double * , const double *
, const int * , double * , NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_compOutputsDyn ( const RuntimeDerivedValuesBundle * , const
int * , const double * , const int * , const double * , const double * ,
const double * , const double * , double * , double * , int * , double * ,
NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_compOutputsKin ( const RuntimeDerivedValuesBundle * , const
double * , const int * , const double * , const double * , const double * ,
const double * , double * , NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_compOutputs ( const RuntimeDerivedValuesBundle * , const
double * , const int * , const double * , const double * , const double * ,
const double * , double * , NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId
Robot_d319c82e_49_computeAsmModeVector ( const double * , const double * ,
const double * , int * , double * , NeuDiagnosticManager * neDiagMgr ) ;
PmfMessageId Robot_d319c82e_49_computeSimModeVector ( const double * , const
double * , const double * , int * , double * , NeuDiagnosticManager *
neDiagMgr ) ; PmfMessageId Robot_d319c82e_49_computeZeroCrossings ( const
RuntimeDerivedValuesBundle * , const double * , const double * , const double
* , const double * , const double * , double * , double * ,
NeuDiagnosticManager * neDiagMgr ) ; PmfMessageId Robot_d319c82e_49_recordLog
( const RuntimeDerivedValuesBundle * , const int * , const double * , const
int * , const double * , const double * , const double * , double * , double
* , NeuDiagnosticManager * neDiagMgr ) ; void Robot_d319c82e_49_setTargets ( const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , CTarget * targets ) ; void Robot_d319c82e_49_resetAsmStateVector ( const void * mech , double * stateVector ) ; void Robot_d319c82e_49_resetSimStateVector ( const void * mech , double * stateVector ) ; void Robot_d319c82e_49_initializeTrackedAngleState ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * modeVector , const double * motionData , double * stateVector ) ; void Robot_d319c82e_49_computeDiscreteState ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * modeVector , double * stateVector ) ; void Robot_d319c82e_49_adjustPosition ( const void * mech , const double * dofDeltas , double * stateVector ) ; void Robot_d319c82e_49_perturbAsmJointPrimitiveState ( const void * mech , size_t stageIdx , size_t primitiveIdx , double magnitude , boolean_T doPerturbVelocity , double * stateVector ) ; void Robot_d319c82e_49_perturbSimJointPrimitiveState ( const void * mech , size_t stageIdx , size_t primitiveIdx , double magnitude , boolean_T doPerturbVelocity , double * stateVector ) ; void Robot_d319c82e_49_perturbFlexibleBodyState ( const void * mech , size_t stageIdx , double magnitude , boolean_T doPerturbVelocity , double * stateVector ) ; void Robot_d319c82e_49_computePosDofBlendMatrix ( const void * mech , size_t stageIdx , size_t primitiveIdx , const double * stateVector , int partialType , double * matrix ) ; void Robot_d319c82e_49_computeVelDofBlendMatrix ( const void * mech , size_t stageIdx , size_t primitiveIdx , const double * stateVector , int partialType , double * matrix ) ; void Robot_d319c82e_49_projectPartiallyTargetedPos ( const void * mech , size_t stageIdx , size_t primitiveIdx , const double * origStateVector , int partialType , double * stateVector ) ; void Robot_d319c82e_49_propagateMotion ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const double * stateVector , double * motionData ) ; void Robot_d319c82e_49_computeTransforms ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const double * stateVector , double * motionData ) ; size_t Robot_d319c82e_49_computeAssemblyPosError ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , size_t constraintIdx , const int * modeVector , const double * motionData , double * error ) ; size_t Robot_d319c82e_49_computeAssemblyJacobian ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , size_t constraintIdx , boolean_T forVelocitySatisfaction , const double * stateVector , const int * modeVector , const double * motionData , double * J ) ; size_t Robot_d319c82e_49_computeFullAssemblyJacobian ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const double * stateVector , const int * modeVector , const double * motionData , double * J ) ; boolean_T Robot_d319c82e_49_isInKinematicSingularity ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , size_t constraintIdx , const int * modeVector , const double * motionData ) ; void Robot_d319c82e_49_convertStateVector ( const void * asmMech , const RuntimeDerivedValuesBundle * asmRuntimeDerivedValuesBundle , const void * simMech , const double * asmStateVector , const int * asmModeVector , const int * simModeVector , double * simStateVector ) ; void Robot_d319c82e_49_constructStateVector ( const void * mech , const double * solverStateVector , const double * u , const double * uDot , const double * discreteStateVector , double * fullStateVector ) ; void Robot_d319c82e_49_extractSolverStateVector ( const void * mech , const double * fullStateVector , double * solverStateVector ) ; void Robot_d319c82e_49_extractDiscreteStateVector ( const void * mech , const double * fullStateVector , double * discreteStateVector ) ; boolean_T Robot_d319c82e_49_isPositionViolation ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * constraintEqnEnableFlags , const double * stateVector , const int * modeVector ) ; boolean_T Robot_d319c82e_49_isVelocityViolation ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * constraintEqnEnableFlags , const double * stateVector , const int * modeVector ) ; PmfMessageId Robot_d319c82e_49_projectStateSim ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * constraintEqnEnableFlags , const int * modeVector , double * stateVector , void * neDiagMgr ) ; void Robot_d319c82e_49_computeConstraintError ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const double * stateVector , const int * modeVector , double * error ) ; void Robot_d319c82e_49_resetModeVector ( const void * mech , int * modeVector ) ; boolean_T Robot_d319c82e_49_hasJointUpwardModeChange ( const void * mech , const int * prevModeVector , const int * modeVector ) ; PmfMessageId Robot_d319c82e_49_performJointUpwardModeChange ( const void * mech , const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle , const int * constraintEqnEnableFlags , const int * prevModeVector , const int * modeVector , const double * inputVector , double * stateVector , void * neDiagMgr ) ; void Robot_d319c82e_49_onModeChangedCutJoints ( const void * mech , const int * prevModeVector , const int * modeVector , double * stateVector ) ; void Robot_d319c82e_49_setVariableModeJointsToLocked ( const void * mech , int * modeVector ) ; PmfMessageId Robot_d319c82e_49_assemble ( const double * u , double * udot , double * x , NeuDiagnosticManager * neDiagMgr ) { ( void ) x ; ( void ) u ; ( void ) udot ; ( void ) neDiagMgr ; return NULL ; } static void dae_cg_setParameters_function ( const NeDae * dae , const NeParameterBundle * paramBundle ) { const NeDaePrivateData * smData = dae -> mPrivateData ; const double * runtimeRootVariables = paramBundle -> mRealParameters . mX ; if ( smData -> mRuntimeParameterScalars . mN == 0 ) return ; Robot_d319c82e_49_computeRuntimeParameters ( runtimeRootVariables , smData -> mRuntimeParameterScalars . mX ) ; Robot_d319c82e_49_computeAsmRuntimeDerivedValues ( smData -> mRuntimeParameterScalars . mX , & dae -> mPrivateData -> mAsmRuntimeDerivedValuesBundle ) ; Robot_d319c82e_49_computeSimRuntimeDerivedValues ( smData -> mRuntimeParameterScalars . mX , & dae -> mPrivateData -> mSimRuntimeDerivedValuesBundle ) ; Robot_d319c82e_49_initializeGeometries ( & smData -> mSimRuntimeDerivedValuesBundle ) ; sm_core_computeRedundantConstraintEquations ( & dae -> mPrivateData -> mSimulationDelegate , & smData -> mSimRuntimeDerivedValuesBundle ) ;
#if 0
{ size_t i ; const size_t n = smData -> mSimulationDelegate .
mRunTimeEnabledEquations . mSize ; pmf_printf ( "\nRuntime Enabled Equations (%lu)\n" , n ) ; for ( i = 0 ; i < n ; ++ i ) pmf_printf ( "  %2lu:  %d\n" , i , smData -> mSimulationDelegate . mRunTimeEnabledEquations . mValues [ i ] ) ; }
#endif
} static PmfMessageId dae_cg_pAssert_method ( const NeDae * dae , const
NeSystemInput * systemInput , NeDaeMethodOutput * daeMethodOutput ,
NeuDiagnosticManager * neDiagMgr ) { const NeDaePrivateData * smData = dae ->
mPrivateData ; const double * runtimeParams = smData ->
mRuntimeParameterScalars . mX ; int32_T * assertSatisfactionFlags =
daeMethodOutput -> mPASSERT . mX ; ( void ) systemInput ; ( void ) neDiagMgr
; Robot_d319c82e_49_validateRuntimeParameters ( runtimeParams ,
assertSatisfactionFlags ) ; return NULL ; } static PmfMessageId
dae_cg_deriv_method ( const NeDae * dae , const NeSystemInput * systemInput ,
NeDaeMethodOutput * daeMethodOutput , NeuDiagnosticManager * neDiagMgr ) {
const NeDaePrivateData * smData = dae -> mPrivateData ; PmfMessageId errorId
= NULL ; double errorResult = 0.0 ; if ( smData ->
mCachedDerivativesAvailable ) memcpy ( daeMethodOutput -> mXP0 . mX , smData
-> mCachedDerivatives . mX , 0 * sizeof ( real_T ) ) ; else errorId =
Robot_d319c82e_49_compDerivs ( & smData -> mSimRuntimeDerivedValuesBundle ,
smData -> mSimulationDelegate . mRunTimeEnabledEquations . mValues ,
systemInput -> mX . mX , systemInput -> mM . mX , systemInput -> mU . mX ,
systemInput -> mU . mX + 6 , systemInput -> mV . mX + 6 , systemInput -> mD .
mX , daeMethodOutput -> mXP0 . mX , & errorResult , neDiagMgr ) ; return
errorId ; } static PmfMessageId dae_cg_numJacPerturbLoBounds_method ( const
NeDae * dae , const NeSystemInput * systemInput , NeDaeMethodOutput *
daeMethodOutput , NeuDiagnosticManager * neDiagMgr ) { const NeDaePrivateData
* smData = dae -> mPrivateData ; PmfMessageId errorId = NULL ; double
errorResult = 0.0 ; errorId = Robot_d319c82e_49_numJacPerturbLoBounds ( &
smData -> mSimRuntimeDerivedValuesBundle , smData -> mSimulationDelegate .
mRunTimeEnabledEquations . mValues , systemInput -> mX . mX , systemInput ->
mM . mX , systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput
-> mV . mX + 6 , systemInput -> mD . mX , daeMethodOutput -> mNUMJAC_DX_LO .
mX , & errorResult , neDiagMgr ) ; return errorId ; } static PmfMessageId
dae_cg_numJacPerturbHiBounds_method ( const NeDae * dae , const NeSystemInput
* systemInput , NeDaeMethodOutput * daeMethodOutput , NeuDiagnosticManager *
neDiagMgr ) { const NeDaePrivateData * smData = dae -> mPrivateData ;
PmfMessageId errorId = NULL ; double errorResult = 0.0 ; errorId =
Robot_d319c82e_49_numJacPerturbHiBounds ( & smData ->
mSimRuntimeDerivedValuesBundle , smData -> mSimulationDelegate .
mRunTimeEnabledEquations . mValues , systemInput -> mX . mX , systemInput ->
mM . mX , systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput
-> mV . mX + 6 , systemInput -> mD . mX , daeMethodOutput -> mNUMJAC_DX_HI .
mX , & errorResult , neDiagMgr ) ; return errorId ; } static PmfMessageId
dae_cg_compOutputs_method ( const NeDae * dae , const NeSystemInput *
systemInput , NeDaeMethodOutput * daeMethodOutput , NeuDiagnosticManager *
neDiagMgr ) { PmfMessageId errorId = NULL ; NeDaePrivateData * smData = dae
-> mPrivateData ; errorId = Robot_d319c82e_49_compOutputs ( & smData ->
mSimRuntimeDerivedValuesBundle , systemInput -> mX . mX , systemInput -> mM .
mX , systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput -> mV
. mX + 6 , systemInput -> mD . mX , daeMethodOutput -> mY . mX , neDiagMgr )
; return errorId ; } static PmfMessageId dae_cg_mode_method ( const NeDae *
dae , const NeSystemInput * systemInput , NeDaeMethodOutput * daeMethodOutput
, NeuDiagnosticManager * neDiagMgr ) { const NeDaePrivateData * smData = dae
-> mPrivateData ; PmfMessageId errorId = NULL ; double errorResult = 0.0 ;
errorId = Robot_d319c82e_49_computeSimModeVector ( systemInput -> mU . mX ,
systemInput -> mU . mX + 6 , systemInput -> mV . mX + 6 , daeMethodOutput ->
mMODE . mX , & errorResult , neDiagMgr ) ; memcpy ( smData ->
mCachedModeVector . mX , daeMethodOutput -> mMODE . mX , 0 * sizeof ( int32_T
) ) ; return errorId ; } static PmfMessageId dae_cg_zeroCrossing_method ( const
NeDae * dae , const NeSystemInput * systemInput , NeDaeMethodOutput *
daeMethodOutput , NeuDiagnosticManager * neDiagMgr ) { const NeDaePrivateData
* smData = dae -> mPrivateData ; double errorResult = 0.0 ; return
Robot_d319c82e_49_computeZeroCrossings ( & smData ->
mSimRuntimeDerivedValuesBundle , systemInput -> mX . mX , systemInput -> mU .
mX , systemInput -> mU . mX + 6 , systemInput -> mV . mX + 6 , systemInput ->
mD . mX , daeMethodOutput -> mZC . mX , & errorResult , neDiagMgr ) ; }
static void dae_cg_setupLoggerFcn ( const NeDae * dae , NeLoggerBuilder *
neLoggerBuilder ) { ( void ) dae ; ( void ) neLoggerBuilder ; } static
PmfMessageId dae_cg_recordLog_method ( const NeDae * dae , const
NeSystemInput * systemInput , PmRealVector * output , NeuDiagnosticManager *
neDiagMgr ) { const NeDaePrivateData * smData = dae -> mPrivateData ;
PmfMessageId errorId = NULL ; double errorResult = 0.0 ; double *
fullStateVector = smData -> mSimulationFullStateVector . mX ;
Robot_d319c82e_49_constructStateVector ( NULL , systemInput -> mX . mX ,
systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput -> mD . mX
, fullStateVector ) ; errorId = Robot_d319c82e_49_recordLog ( & smData ->
mSimRuntimeDerivedValuesBundle , smData -> mSimulationDelegate .
mRunTimeEnabledEquations . mValues , fullStateVector , systemInput -> mM . mX
, systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput -> mV .
mX + 6 , output -> mX , & errorResult , neDiagMgr ) ; return errorId ; }
static PmfMessageId dae_cg_project_solve ( const NeDae * dae , const
NeSystemInput * systemInput , NeuDiagnosticManager * neDiagMgr ) {
NeDaePrivateData * smData = dae -> mPrivateData ; return sm_core_projectState
( false , & smData -> mSimulationDelegate , & smData ->
mSimRuntimeDerivedValuesBundle , systemInput -> mM . mX , systemInput -> mU .
mX , systemInput -> mU . mX + 6 , systemInput -> mD . mX , systemInput -> mX
. mX , neDiagMgr ) ; } static PmfMessageId dae_cg_check_solve ( const NeDae *
dae , const NeSystemInput * systemInput , NeuDiagnosticManager * neDiagMgr )
{ NeDaePrivateData * smData = dae -> mPrivateData ; PmfMessageId errorId =
NULL ; if ( smData -> mNumConstraintEqns > 0 ) errorId = sm_core_projectState
( false , & smData -> mSimulationDelegate , & smData ->
mSimRuntimeDerivedValuesBundle , systemInput -> mM . mX , systemInput -> mU .
mX , systemInput -> mU . mX + 6 , systemInput -> mD . mX , systemInput -> mX
. mX , neDiagMgr ) ; if ( errorId == NULL ) { double result = 0.0 ; errorId =
Robot_d319c82e_49_checkDynamics ( & smData -> mSimRuntimeDerivedValuesBundle
, systemInput -> mX . mX , systemInput -> mU . mX , systemInput -> mU . mX +
6 , systemInput -> mV . mX + 6 , systemInput -> mD . mX , systemInput -> mM .
mX , & result , neDiagMgr ) ; } return errorId ; } static PmfMessageId
dae_cg_CIC_MODE_solve ( const NeDae * dae , const NeSystemInput * systemInput
, NeuDiagnosticManager * neDiagMgr ) { NeDaePrivateData * smData = dae ->
mPrivateData ; PmfMessageId errorId = NULL ; double errorResult = 0.0 ; const
size_t mvSize = smData -> mModeVectorSize ; boolean_T modeChanged = false ;
if ( mvSize > 0 ) { errorId = Robot_d319c82e_49_computeSimModeVector ( systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput -> mV . mX + 6 , systemInput -> mM . mX , & errorResult , neDiagMgr ) ; if ( errorId != NULL ) return errorId ; { size_t i ; for ( i = 0 ; i < mvSize ; ++ i ) if ( systemInput -> mM . mX [ i ] != smData -> mCachedModeVector . mX [ i ] ) { modeChanged = true ; break ; } } } if ( modeChanged ) { errorId = sm_core_onModeChanged ( & smData -> mSimulationDelegate , & smData -> mSimRuntimeDerivedValuesBundle , systemInput -> mU . mX , systemInput -> mU . mX + 6 , smData -> mCachedModeVector . mX , systemInput -> mM . mX , systemInput -> mX . mX , systemInput -> mD . mX , neDiagMgr ) ; if ( errorId != NULL ) return errorId ; memcpy ( smData -> mCachedModeVector . mX , systemInput -> mM . mX , 0 * sizeof ( int32_T ) ) ; } errorId = sm_core_projectState ( true , & smData -> mSimulationDelegate , & smData -> mSimRuntimeDerivedValuesBundle , systemInput -> mM . mX , systemInput -> mU . mX , systemInput -> mU . mX + 6 , systemInput -> mD . mX , systemInput -> mX . mX , neDiagMgr ) ; return errorId ; } static PmfMessageId dae_cg_assemble_solve ( const NeDae * dae , const NeSystemInput * systemInput , NeuDiagnosticManager * neDiagMgr ) { NeDaePrivateData * smData = dae -> mPrivateData ; const SmMechanismDelegate * delegate = & smData -> mAssemblyDelegate ; const RuntimeDerivedValuesBundle * runtimeDerivedValuesBundle = & smData -> mAsmRuntimeDerivedValuesBundle ; PmfMessageId errorId = NULL ; size_t i ; double errorResult = 0.0 ; const size_t numTargets = 24 ; unsigned int asmStatus = 0 ; double * assemblyFullStateVector = smData -> mAssemblyFullStateVector . mX ; double * simulationFullStateVector = smData -> mSimulationFullStateVector . mX ; const double * u = systemInput -> mU . mX ; const double * uDot = u + smData -> mInputVectorSize ; const double * uDDot = systemInput -> mV . mX + smData -> mInputVectorSize ; if ( smData -> mAssemblyModeVector . mN > 0 ) { errorId = Robot_d319c82e_49_computeAsmModeVector ( u , uDot , uDDot , smData -> mAssemblyModeVector . mX , & errorResult , neDiagMgr ) ; if ( errorId != NULL ) return errorId ; } if ( smData -> mModeVectorSize > 0 ) { errorId = Robot_d319c82e_49_computeSimModeVector ( u , uDot , uDDot , systemInput -> mM . mX , & errorResult , neDiagMgr ) ; if ( errorId != NULL ) return errorId ; memcpy ( smData -> mCachedModeVector . mX , systemInput -> mM . mX , 0 * sizeof ( int32_T ) ) ; } ( * delegate -> mSetTargets ) ( runtimeDerivedValuesBundle , smData -> mTargets ) ; { CTarget * target = smData -> mTargets + smData -> mNumInternalTargets ; for ( i = 0 ; i < smData -> mNumMotionInputPrimitives ; ++ i ) { const size_t inputOffset = smData -> mMotionInputOffsets . mX [ i ] ; sm_compiler_CTarget_setValue ( & u [ inputOffset ] , 1 , target ++ ) ; sm_compiler_CTarget_setValue ( & uDot [ inputOffset ] , 1 , target ++ ) ; } for ( i = 0 ; i < smData -> mNumMaybeLockedPrimitives ; ++ i ) { const boolean_T hasMode = smData -> mMaybeLockedPrimHasModes . mX [ i ] ; const size_t modeOffset = smData -> mMaybeLockedPrimModeOffsets . mX [ i ] ; if ( hasMode && systemInput -> mM . mX [ modeOffset ] != 1 ) target -> mStrength = 0 ; else target -> mStrength = 3 ; ++ target ; } } sm_core_computeStateVector ( delegate , runtimeDerivedValuesBundle , smData -> mAssemblyModeVector . mX , numTargets , smData -> mTargets , assemblyFullStateVector ) ; asmStatus = sm_core_checkAssembly ( delegate , runtimeDerivedValuesBundle , assemblyFullStateVector , smData -> mAssemblyModeVector . mX , NULL , NULL , NULL ) ; if ( asmStatus != 1 ) { return sm_ssci_recordRunTimeError ( "physmod:sm:ssci:core:dae:dae:assemblyFailure" , asmStatus == 2 ? "Model not assembled. The following violation occurred: Position Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly." : ( asmStatus == 3 ? "Model not assembled. The following violation occurred: Velocity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly." : "Model not assembled. The following violation occurred: Singularity Violation. The failure occurred during the attempt to assemble all joints in the system and satisfy any motion inputs. If an Update Diagram operation completes successfully, the failure is likely caused by motion inputs. Consider adjusting the motion inputs to specify a different starting configuration. Also consider adjusting or adding joint targets to better guide the assembly." ) , neDiagMgr ) ; }
#if 0
Robot_d319c82e_49_checkTargets ( & smData -> mSimRuntimeDerivedValuesBundle ,
assemblyFullStateVector ) ;
#endif
( * delegate -> mConvertStateVector ) ( NULL , runtimeDerivedValuesBundle ,
NULL , assemblyFullStateVector , smData -> mAssemblyModeVector . mX ,
systemInput -> mM . mX , simulationFullStateVector ) ; for ( i = 0 ; i <
smData -> mStateVectorSize ; ++ i ) systemInput -> mX . mX [ i ] =
simulationFullStateVector [ smData -> mStateVectorMap . mX [ i ] ] ; memcpy ( systemInput -> mD . mX , simulationFullStateVector + smData -> mFullStateVectorSize - smData -> mDiscreteStateSize , smData -> mDiscreteStateSize * sizeof ( double ) ) ; return errorId ; } typedef struct { size_t first ; size_t second ; } SizePair ; static void checkMemAllocStatus ( int_T status ) { ( void ) status ; } static PmCharVector cStringToCharVector ( const char * src ) { const size_t n = strlen ( src ) ; PmCharVector charVect ; const int_T status = pm_create_char_vector_fields ( & charVect , n + 1 , pm_default_allocator ( ) ) ; checkMemAllocStatus ( status ) ; strcpy ( charVect . mX , src ) ; return charVect ; } static void initBasicAttributes ( NeDaePrivateData * smData ) { size_t i ; smData -> mStateVectorSize = 0 ; smData -> mFullStateVectorSize = 12 ; smData -> mDiscreteStateSize = 0 ; smData -> mModeVectorSize = 0 ; smData -> mNumZeroCrossings = 0 ; smData -> mInputVectorSize = 6 ; smData -> mOutputVectorSize = 6 ; smData -> mNumConstraintEqns = 0 ; smData -> mFundamentalSampleTime = + 0.000000000000000000e+00 ; for ( i = 0 ; i < 4 ; ++ i ) smData -> mChecksum [ i ] = 0 ; } static void initStateVector ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; static const int32_T * stateVectorMap = NULL ; static real_T targetVals [ 24 ] = { - 1.144067060458681118e-01 , + 0.000000000000000000e+00 , - 1.633260246034572205e+00 , + 0.000000000000000000e+00 , + 1.633260246034572205e+00 , + 0.000000000000000000e+00 , + 2.220446049250312341e-16 , + 0.000000000000000000e+00 , - 5.051831958664159521e-14 , + 0.000000000000000000e+00 , - 5.051831958664159521e-14 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 , + 0.000000000000000000e+00 } ; static const CTarget targets [ 24 ] = { { 0 , 82 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 0 ] } , { + 0.000000000000000000e+00 } } , { 0 , 82 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 1 ] } , { + 0.000000000000000000e+00 } } , { 0 , 83 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 2 ] } , { + 0.000000000000000000e+00 } } , { 0 , 83 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 3 ] } , { + 0.000000000000000000e+00 } } , { 0 , 84 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 4 ] } , { + 0.000000000000000000e+00 } } , { 0 , 84 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 5 ] } , { + 0.000000000000000000e+00 } } , { 0 , 85 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 6 ] } , { + 0.000000000000000000e+00 } } , { 0 , 85 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 7 ] } , { + 0.000000000000000000e+00 } } , { 0 , 86 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 8 ] } , { + 0.000000000000000000e+00 } } , { 0 , 86 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 9 ] } , { + 0.000000000000000000e+00 } } , { 0 , 87 , false , 0 , 1 , "deg" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 10 ] } , { + 0.000000000000000000e+00 } } , { 0 , 87 , false , 0 , 0 , "1" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 11 ] } , { + 0.000000000000000000e+00 } } , { 0 , 82 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 12 ] } , { + 0.000000000000000000e+00 } } , { 0 , 82 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 13 ] } , { + 0.000000000000000000e+00 } } , { 0 , 83 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 14 ] } , { + 0.000000000000000000e+00 } } , { 0 , 83 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 15 ] } , { + 0.000000000000000000e+00 } } , { 0 , 84 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 16 ] } , { + 0.000000000000000000e+00 } } , { 0 , 84 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 17 ] } , { + 0.000000000000000000e+00 } } , { 0 , 85 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 18 ] } , { + 0.000000000000000000e+00 } } , { 0 , 85 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 19 ] } , { + 0.000000000000000000e+00 } } , { 0 , 86 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 20 ] } , { + 0.000000000000000000e+00 } } , { 0 , 86 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 21 ] } , { + 0.000000000000000000e+00 } } , { 0 , 87 , false , 0 , 3 , "" , 0 , false , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 22 ] } , { + 0.000000000000000000e+00 } } , { 0 , 87 , false , 0 , 3 , "" , 0 , true , true , + 1.000000000000000000e+00 , false , { 1 , 1 , & targetVals [ 23 ] } , { + 0.000000000000000000e+00 } } } ; int_T status ; size_t i ; status = pm_create_real_vector_fields ( & smData -> mAssemblyFullStateVector , 12 , alloc ) ; checkMemAllocStatus ( status ) ; status = pm_create_real_vector_fields ( & smData -> mSimulationFullStateVector , 12 , alloc ) ; checkMemAllocStatus ( status ) ; status = pm_create_int_vector_fields ( & smData -> mStateVectorMap , smData -> mStateVectorSize , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mStateVectorMap . mX , stateVectorMap , smData -> mStateVectorSize * sizeof ( int32_T ) ) ; smData -> mNumInternalTargets = 12 ; smData -> mNumMotionInputPrimitives = 6 ; smData -> mNumMaybeLockedPrimitives = 0 ; smData -> mNumTargets = 24 ; PM_ALLOCATE_ARRAY ( smData -> mTargets , CTarget , smData -> mNumTargets , alloc ) ; for ( i = 0 ; i < smData -> mNumTargets ; ++ i ) sm_compiler_CTarget_copy ( targets + i , smData -> mTargets + i ) ; } static void initAsserts ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; int_T status = 0 ; smData -> mNumParamAsserts = 0 ; smData -> mParamAssertObjects = NULL ; smData -> mParamAssertPaths = NULL ; smData -> mParamAssertDescriptors = NULL ; smData -> mParamAssertMessages = NULL ; smData -> mParamAssertMessageIds = NULL ; status = pm_create_bool_vector_fields ( & smData -> mParamAssertIsWarnings , smData -> mNumParamAsserts , alloc ) ; checkMemAllocStatus ( status ) ; if ( smData -> mNumParamAsserts > 0 ) { const NeAssertData * ad = Robot_d319c82e_49_assertData ; size_t i ; PM_ALLOCATE_ARRAY ( smData -> mParamAssertObjects , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mParamAssertPaths , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mParamAssertDescriptors , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mParamAssertMessages , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mParamAssertMessageIds , PmCharVector , 0 , alloc ) ; for ( i = 0 ; i < smData -> mNumParamAsserts ; ++ i , ++ ad ) { smData -> mParamAssertObjects [ i ] = cStringToCharVector ( ad -> mObject ) ; smData -> mParamAssertPaths [ i ] = cStringToCharVector ( ad -> mPath ) ; smData -> mParamAssertDescriptors [ i ] = cStringToCharVector ( ad -> mDescriptor ) ; smData -> mParamAssertMessages [ i ] = cStringToCharVector ( ad -> mMessage ) ; smData -> mParamAssertMessageIds [ i ] = cStringToCharVector ( ad -> mMessageID ) ; smData -> mParamAssertIsWarnings . mX [ i ] = ad -> mIsWarn ; } } } static void initModeVector ( NeDaePrivateData * smData ) { { size_t i ; const int_T status = pm_create_int_vector_fields ( & smData -> mAssemblyModeVector , 0 , pm_default_allocator ( ) ) ; checkMemAllocStatus ( status ) ; for ( i = 0 ; i < smData -> mAssemblyModeVector . mN ; ++ i ) smData -> mAssemblyModeVector . mX [ i ] = 0 ; } { size_t i ; const int_T status = pm_create_int_vector_fields ( & smData -> mCachedModeVector , 0 , pm_default_allocator ( ) ) ; checkMemAllocStatus ( status ) ; for ( i = 0 ; i < smData -> mModeVectorSize ; ++ i ) smData -> mCachedModeVector . mX [ i ] = 0 ; } } static void initZeroCrossings ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; int_T status = 0 ; smData -> mZeroCrossingObjects = NULL ; smData -> mZeroCrossingPaths = NULL ; smData -> mZeroCrossingDescriptors = NULL ; status = pm_create_int_vector_fields ( & smData -> mZeroCrossingTypes , 0 , alloc ) ; checkMemAllocStatus ( status ) ; if ( smData -> mNumZeroCrossings > 0 ) { const NeZCData * zcd = Robot_d319c82e_49_ZCData ; size_t i ; PM_ALLOCATE_ARRAY ( smData -> mZeroCrossingObjects , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mZeroCrossingPaths , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mZeroCrossingDescriptors , PmCharVector , 0 , alloc ) ; for ( i = 0 ; i < smData -> mNumZeroCrossings ; ++ i , ++ zcd ) { smData -> mZeroCrossingObjects [ i ] = cStringToCharVector ( zcd -> mObject ) ; smData -> mZeroCrossingPaths [ i ] = cStringToCharVector ( zcd -> mPath ) ; smData -> mZeroCrossingDescriptors [ i ] = cStringToCharVector ( zcd -> mDescriptor ) ; smData -> mZeroCrossingTypes . mX [ i ] = zcd -> mType ; } } } static void initVariables ( NeDaePrivateData * smData ) { static const char * * varFullPaths = NULL ; static const char * * varObjects = NULL ; static const char * * varEncodedDims = NULL ; static const size_t * varNumels = NULL ; smData -> mNumVarScalars = 0 ; smData -> mVarFullPaths = NULL ; smData -> mVarObjects = NULL ; smData -> mVarEncodedDims = NULL ; if ( smData -> mNumVarScalars > 0 ) { size_t s ; PmAllocator * alloc = pm_default_allocator ( ) ; int_T status = 0 ; PM_ALLOCATE_ARRAY ( smData -> mVarFullPaths , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mVarObjects , PmCharVector , 0 , alloc ) ; PM_ALLOCATE_ARRAY ( smData -> mVarEncodedDims , PmCharVector , 0 , alloc ) ; for ( s = 0 ; s < smData -> mNumVarScalars ; ++ s ) { smData -> mVarFullPaths [ s ] = cStringToCharVector ( varFullPaths [ s ] ) ; smData -> mVarObjects [ s ] = cStringToCharVector ( varObjects [ s ] ) ; smData -> mVarEncodedDims [ s ] = cStringToCharVector ( varEncodedDims [ s ] ) ; } status = pm_create_size_vector_fields ( & smData -> mVarNumels , smData -> mNumVarScalars , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mVarNumels . mX , varNumels , 0 * sizeof ( size_t ) ) ; } } static void initRuntimeParameters ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; int_T status = 0 ; size_t i = 0 ; static const int32_T * rtpRootVarNumels = NULL ; static const char * * rtpFullPaths = NULL ; smData -> mNumRtpRootVars = 0 ; status = pm_create_int_vector_fields ( & smData -> mRtpRootVarNumels , smData -> mNumRtpRootVars , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mRtpRootVarNumels . mX , rtpRootVarNumels , smData -> mNumRtpRootVars * sizeof ( int32_T ) ) ; smData -> mRtpFullPaths = NULL ; if ( smData -> mNumRtpRootVars > 0 ) { size_t v ; PM_ALLOCATE_ARRAY ( smData -> mRtpFullPaths , PmCharVector , 0 , alloc ) ; for ( v = 0 ; v < smData -> mNumRtpRootVars ; ++ v ) { smData -> mRtpFullPaths [ v ] = cStringToCharVector ( rtpFullPaths [ v ] ) ; } } smData -> mNumRuntimeRootVarScalars = 0 ; status = pm_create_real_vector_fields ( & smData -> mRuntimeParameterScalars , 0 , alloc ) ; checkMemAllocStatus ( status ) ; for ( i = 0 ; i < smData -> mRuntimeParameterScalars . mN ; ++ i ) smData -> mRuntimeParameterScalars . mX [ i ] = 0.0 ; sm_core_RuntimeDerivedValuesBundle_create ( & smData -> mAsmRuntimeDerivedValuesBundle , 0 , 0 ) ; sm_core_RuntimeDerivedValuesBundle_create ( & smData -> mSimRuntimeDerivedValuesBundle , 0 , 0 ) ; } static void initIoInfoHelper ( size_t n , const char * portPathsSource [ ] , const char * unitsSource [ ] , const SscArraySize dimensions [ ] , boolean_T doInputs , NeDaePrivateData * smData ) { PmCharVector * portPaths = NULL ; PmCharVector * units = NULL ; SscIoInfo * infos = NULL ; if ( n > 0 ) { size_t s ; PmAllocator * alloc = pm_default_allocator ( ) ; PM_ALLOCATE_ARRAY ( portPaths , PmCharVector , n , alloc ) ; PM_ALLOCATE_ARRAY ( units , PmCharVector , n , alloc ) ; PM_ALLOCATE_ARRAY ( infos , SscIoInfo , n , alloc ) ; for ( s = 0 ; s < n ; ++ s ) { portPaths [ s ] = cStringToCharVector ( portPathsSource [ s ] ) ; units [ s ] = cStringToCharVector ( unitsSource [ s ] ) ; { SscIoInfo * info = infos + s ; info -> name = info -> identifier = portPaths [ s ] . mX ; info -> size = dimensions [ s ] ; info -> unit = units [ s ] . mX ; } } } if ( doInputs ) { smData -> mNumInputs = n ; smData -> mInputPortPaths = portPaths ; smData -> mInputUnits = units ; smData -> mInputInfos = infos ; } else { smData -> mNumOutputs = n ; smData -> mOutputPortPaths = portPaths ; smData -> mOutputUnits = units ; smData -> mOutputInfos = infos ; } } static void initIoInfo ( NeDaePrivateData * smData ) { static const char * inputPortPaths [ 6 ] = { "Subsystem.Revolute0.q_in" , "Subsystem.Revolute1.q_in" , "Subsystem.Revolute2.q_in" , "Subsystem.Revolute3.q_in" , "Subsystem.Revolute4.q_in" , "Subsystem.Revolute5.q_in" } ; static const char * inputUnits [ 6 ] = { "rad" , "rad" , "rad" , "rad" , "rad" , "rad" } ; static const SscArraySize inputDimensions [ 6 ] = { { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } } ; static const char * outputPortPaths [ 6 ] = { "Subsystem.Revolute0.q_out" , "Subsystem.Revolute1.q_out" , "Subsystem.Revolute2.q_out" , "Subsystem.Revolute3.q_out" , "Subsystem.Revolute4.q_out" , "Subsystem.Revolute5.q_out" } ; static const char * outputUnits [ 6 ] = { "rad" , "rad" , "rad" , "rad" , "rad" , "rad" } ; static const SscArraySize outputDimensions [ 6 ] = { { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } , { 1 , "1x1" } } ; initIoInfoHelper ( 6 , inputPortPaths , inputUnits , inputDimensions , true , smData ) ; initIoInfoHelper ( 6 , outputPortPaths , outputUnits , outputDimensions , false , smData ) ; } static void initInputDerivs ( NeDaePrivateData * smData ) { static const int32_T numInputDerivs [ 6 ] = { 2 , 2 , 2 , 2 , 2 , 2 } ; PmAllocator * alloc = pm_default_allocator ( ) ; const int_T status = pm_create_int_vector_fields ( & smData -> mNumInputDerivs , smData -> mInputVectorSize , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mNumInputDerivs . mX , numInputDerivs , 6 * sizeof ( int32_T ) ) ; smData -> mInputOrder = 2 ; } static void initDirectFeedthrough ( NeDaePrivateData * smData ) { static const boolean_T directFeedthroughVector [ 6 ] = { true , true , true , true , true , true } ; static const boolean_T directFeedthroughMatrix [ 72 ] = { true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true , true } ; PmAllocator * alloc = pm_default_allocator ( ) ; { const int_T status = pm_create_bool_vector_fields ( & smData -> mDirectFeedthroughVector , 6 , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mDirectFeedthroughVector . mX , directFeedthroughVector , 6 * sizeof ( boolean_T ) ) ; } { const int_T status = pm_create_bool_vector_fields ( & smData -> mDirectFeedthroughMatrix , 72 , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mDirectFeedthroughMatrix . mX , directFeedthroughMatrix , 72 * sizeof ( boolean_T ) ) ; } } static void initOutputDerivProc ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; static const int32_T outputFunctionMap [ 6 ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; smData -> mOutputFunctionMap = pm_create_int_vector ( 6 , alloc ) ; memcpy ( smData -> mOutputFunctionMap -> mX , outputFunctionMap , 6 * sizeof ( int32_T ) ) ; smData -> mNumOutputClasses = 1 ; smData -> mHasKinematicOutputs = true ; smData -> mHasDynamicOutputs = false ; smData -> mIsOutputClass0Dynamic = false ; smData -> mDoComputeDynamicOutputs = false ; smData -> mCachedDerivativesAvailable = false ; { size_t i = 0 ; const int_T status = pm_create_real_vector_fields ( & smData -> mCachedDerivatives , 0 , pm_default_allocator ( ) ) ; checkMemAllocStatus ( status ) ; for ( i = 0 ; i < smData -> mCachedDerivatives . mN ; ++ i ) smData -> mCachedDerivatives . mX [ i ] = 0.0 ; } }
#if 0
static void initializeSizePairVector ( const SmSizePair * data ,
SmSizePairVector * vector ) { const size_t n = sm_core_SmSizePairVector_size
( vector ) ; size_t i ; for ( i = 0 ; i < n ; ++ i , ++ data )
sm_core_SmSizePairVector_setValue ( vector , i , data ++ ) ; }
#endif
static void initAssemblyDelegate ( SmMechanismDelegate * delegate ) {
SmMechanismDelegateScratchpad * scratchpad = NULL ; static const SmSizePair
jointToStageIdx [ 6 ] = { { 82 , 0 } , { 83 , 1 } , { 84 , 2 } , { 85 , 3 } ,
{ 86 , 4 } , { 87 , 5 } } ; static const size_t primitiveIndices [ 6 + 1 ] =
{ 0 , 1 , 2 , 3 , 4 , 5 , 6 } ; static const SmSizePair stateOffsets [ 6 ] =
{ { 0 , 1 } , { 2 , 3 } , { 4 , 5 } , { 6 , 7 } , { 8 , 9 } , { 10 , 11 } } ;
static const SmSizePair dofOffsets [ 6 ] = { { 0 , 1 } , { 1 , 2 } , { 2 , 3
} , { 3 , 4 } , { 4 , 5 } , { 5 , 6 } } ; static const SmSizePair *
flexBodyToStageIdx = NULL ; static const SmSizePair * flexStateOffsets = NULL
; static const size_t * flexibleStages = NULL ; static const size_t
remodIndices [ 6 ] = { 0 , 2 , 4 , 6 , 8 , 10 } ; static const size_t *
equationsPerConstraint = NULL ; static const int32_T *
hasAllVelocityDisabledEquations = NULL ; static const int32_T *
runtimeEnabledEquations = NULL ; static const size_t dofToVelSlot [ 6 ] = { 1
, 3 , 5 , 7 , 9 , 11 } ; static const size_t * constraintDofs = NULL ; static
const size_t constraintDofOffsets [ 0 + 1 ] = { 0 } ; const size_t Jm = 0 ;
const size_t Jn = 6 ; SmSizePair zeroSizePair ; zeroSizePair . mFirst =
zeroSizePair . mSecond = 0 ; sm_core_MechanismDelegate_allocScratchpad ( delegate ) ; scratchpad = delegate -> mScratchpad ; delegate -> mTargetStrengthFree = 0 ; delegate -> mTargetStrengthSuggested = 1 ; delegate -> mTargetStrengthDesired = 2 ; delegate -> mTargetStrengthRequired = 3 ; delegate -> mConsistencyTol = + 1.000000000000000062e-09 ; delegate -> mTreeJointDof = 6 ; delegate -> mDof = 6 ; delegate -> mStateSize = 12 ; delegate -> mContinuousStateSize = 12 ; delegate -> mModeVectorSize = 0 ; delegate -> mNumStages = 6 ; delegate -> mNumConstraints = 0 ; delegate -> mNumAllConstraintEquations = 0 ; sm_core_SmSizePairVector_create ( & delegate -> mJointToStageIdx , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mJointToStageIdx ) , jointToStageIdx , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mPrimitiveIndices , delegate -> mNumStages + 1 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mPrimitiveIndices ) , primitiveIndices , ( delegate -> mNumStages + 1 ) * sizeof ( size_t ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mStateOffsets , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mStateOffsets ) , stateOffsets , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mDofOffsets , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mDofOffsets ) , dofOffsets , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mFlexBodyToStageIdx , 0 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mFlexBodyToStageIdx ) , flexBodyToStageIdx , 0 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mFlexStateOffsets , 0 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mFlexStateOffsets ) , flexStateOffsets , 0 * sizeof ( SmSizePair ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mFlexibleStages , 0 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mFlexibleStages ) , flexibleStages , 0 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mRemodIndices , 6 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mRemodIndices ) , remodIndices , 6 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mEquationsPerConstraint , delegate -> mNumConstraints , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mEquationsPerConstraint ) , equationsPerConstraint , delegate -> mNumConstraints * sizeof ( size_t ) ) ; sm_core_SmIntVector_create ( & delegate -> mHasAllVelocityDisabledEquations , delegate -> mNumConstraints , 0 ) ; memcpy ( sm_core_SmIntVector_nonConstValues ( & delegate -> mHasAllVelocityDisabledEquations ) , hasAllVelocityDisabledEquations , delegate -> mNumConstraints * sizeof ( int32_T ) ) ; sm_core_SmIntVector_create ( & delegate -> mRunTimeEnabledEquations , delegate -> mNumAllConstraintEquations , 0 ) ; memcpy ( sm_core_SmIntVector_nonConstValues ( & delegate -> mRunTimeEnabledEquations ) , runtimeEnabledEquations , delegate -> mNumAllConstraintEquations * sizeof ( int32_T ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mDofToVelSlot , delegate -> mDof , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mDofToVelSlot ) , dofToVelSlot , delegate -> mDof * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mConstraintDofs , 0 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mConstraintDofs ) , constraintDofs , 0 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mConstraintDofOffsets , delegate -> mNumConstraints + 1 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mConstraintDofOffsets ) , constraintDofOffsets , ( delegate -> mNumConstraints + 1 ) * sizeof ( size_t ) ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosDesired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosSuggested , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosNonRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosSuggAndFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelDesired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelSuggested , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelNonRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelSuggAndFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mConstraintFilter , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveConstraints , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveDofs , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveDofs0 , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mNewConstraints , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mNewDofs , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mUnsatisfiedConstraints , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mActiveConstraintsVect , 0 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mActiveDofsVect , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mFullDofToActiveDof , 6 , 0 ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mPartiallyPosTargetedPrims , 6 , & zeroSizePair ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mPartiallyVelTargetedPrims , 6 , & zeroSizePair ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mPosPartialTypes , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mVelPartialTypes , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mPartiallyActivePrims , 6 , 0 ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mBaseFrameVelOffsets , 0 , & zeroSizePair ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mCvQuaternionVelOffsets , 0 , & zeroSizePair ) ; sm_core_SmRealVector_create ( & scratchpad -> mCvQuaternionAzimuthValues , 0 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mInitialState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mStartState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mTestState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mFullStateVector , 12 , 0.0 ) ; sm_core_SmIntVector_create ( & scratchpad -> mModeVector , 0 , 0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobianRowMaj , Jm * Jn , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobian , Jm * Jn , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobianPrimSubmatrix , Jm * 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mConstraintNonhomoTerms , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mConstraintError , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mBestConstraintError , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mDeltas , Jn * ( Jm <= Jn ? Jm : Jn ) , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mSvdWork , 49 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchScaledDeltaVect , 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchTestStateVect , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchErrorVect , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mActiveDofVelsVect , 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mVelSystemRhs , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mMotionData , 78 , 0.0 ) ; delegate -> mSetTargets = Robot_d319c82e_49_setTargets ; delegate -> mResetStateVector = Robot_d319c82e_49_resetAsmStateVector ; delegate -> mInitializeTrackedAngleState = Robot_d319c82e_49_initializeTrackedAngleState ; delegate -> mComputeDiscreteState = Robot_d319c82e_49_computeDiscreteState ; delegate -> mAdjustPosition = Robot_d319c82e_49_adjustPosition ; delegate -> mPerturbJointPrimitiveState = Robot_d319c82e_49_perturbAsmJointPrimitiveState ; delegate -> mPerturbFlexibleBodyState = NULL ; delegate -> mComputePosDofBlendMatrix = Robot_d319c82e_49_computePosDofBlendMatrix ; delegate -> mComputeVelDofBlendMatrix = Robot_d319c82e_49_computeVelDofBlendMatrix ; delegate -> mProjectPartiallyTargetedPos = Robot_d319c82e_49_projectPartiallyTargetedPos ; delegate -> mPropagateMotion = Robot_d319c82e_49_propagateMotion ; delegate -> mComputeTransforms = Robot_d319c82e_49_computeTransforms ; delegate -> mComputeAssemblyPosError = Robot_d319c82e_49_computeAssemblyPosError ; delegate -> mComputeAssemblyJacobian = Robot_d319c82e_49_computeAssemblyJacobian ; delegate -> mComputeFullAssemblyJacobian = Robot_d319c82e_49_computeFullAssemblyJacobian ; delegate -> mIsInKinematicSingularity = Robot_d319c82e_49_isInKinematicSingularity ; delegate -> mConvertStateVector = Robot_d319c82e_49_convertStateVector ; delegate -> mConstructStateVector = NULL ; delegate -> mExtractSolverStateVector = NULL ; delegate -> mExtractDiscreteStateVector = NULL ; delegate -> mIsPositionViolation = NULL ; delegate -> mIsVelocityViolation = NULL ; delegate -> mProjectStateSim = NULL ; delegate -> mComputeConstraintError = NULL ; delegate -> mResetModeVector = NULL ; delegate -> mHasJointUpwardModeChange = NULL ; delegate -> mPerformJointUpwardModeChange = NULL ; delegate -> mOnModeChangedCutJoints = NULL ; delegate -> mSetVariableModeJointsToLocked = NULL ; delegate -> mMech = NULL ; } static void initSimulationDelegate ( SmMechanismDelegate * delegate ) { SmMechanismDelegateScratchpad * scratchpad = NULL ; static const SmSizePair jointToStageIdx [ 6 ] = { { 82 , 0 } , { 83 , 1 } , { 84 , 2 } , { 85 , 3 } , { 86 , 4 } , { 87 , 5 } } ; static const size_t primitiveIndices [ 6 + 1 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 } ; static const SmSizePair stateOffsets [ 6 ] = { { 0 , 1 } , { 2 , 3 } , { 4 , 5 } , { 6 , 7 } , { 8 , 9 } , { 10 , 11 } } ; static const SmSizePair dofOffsets [ 6 ] = { { 0 , 1 } , { 1 , 2 } , { 2 , 3 } , { 3 , 4 } , { 4 , 5 } , { 5 , 6 } } ; static const SmSizePair * flexBodyToStageIdx = NULL ; static const SmSizePair * flexStateOffsets = NULL ; static const size_t * flexibleStages = NULL ; static const size_t remodIndices [ 6 ] = { 0 , 2 , 4 , 6 , 8 , 10 } ; static const size_t * equationsPerConstraint = NULL ; static const int32_T * hasAllVelocityDisabledEquations = NULL ; static const int32_T * runtimeEnabledEquations = NULL ; static const size_t dofToVelSlot [ 6 ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; static const size_t * constraintDofs = NULL ; static const size_t constraintDofOffsets [ 0 + 1 ] = { 0 } ; const size_t Jm = 0 ; const size_t Jn = 6 ; SmSizePair zeroSizePair ; zeroSizePair . mFirst = zeroSizePair . mSecond = 0 ; sm_core_MechanismDelegate_allocScratchpad ( delegate ) ; scratchpad = delegate -> mScratchpad ; delegate -> mTargetStrengthFree = 0 ; delegate -> mTargetStrengthSuggested = 1 ; delegate -> mTargetStrengthDesired = 2 ; delegate -> mTargetStrengthRequired = 3 ; delegate -> mConsistencyTol = + 1.000000000000000062e-09 ; delegate -> mTreeJointDof = 6 ; delegate -> mDof = 6 ; delegate -> mStateSize = 12 ; delegate -> mContinuousStateSize = 12 ; delegate -> mModeVectorSize = 0 ; delegate -> mNumStages = 6 ; delegate -> mNumConstraints = 0 ; delegate -> mNumAllConstraintEquations = 0 ; sm_core_SmSizePairVector_create ( & delegate -> mJointToStageIdx , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mJointToStageIdx ) , jointToStageIdx , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mPrimitiveIndices , delegate -> mNumStages + 1 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mPrimitiveIndices ) , primitiveIndices , ( delegate -> mNumStages + 1 ) * sizeof ( size_t ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mStateOffsets , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mStateOffsets ) , stateOffsets , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mDofOffsets , 6 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mDofOffsets ) , dofOffsets , 6 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mFlexBodyToStageIdx , 0 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mFlexBodyToStageIdx ) , flexBodyToStageIdx , 0 * sizeof ( SmSizePair ) ) ; sm_core_SmSizePairVector_create ( & delegate -> mFlexStateOffsets , 0 , & zeroSizePair ) ; memcpy ( sm_core_SmSizePairVector_nonConstValues ( & delegate -> mFlexStateOffsets ) , flexStateOffsets , 0 * sizeof ( SmSizePair ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mFlexibleStages , 0 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mFlexibleStages ) , flexibleStages , 0 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mRemodIndices , 6 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mRemodIndices ) , remodIndices , 6 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mEquationsPerConstraint , delegate -> mNumConstraints , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mEquationsPerConstraint ) , equationsPerConstraint , delegate -> mNumConstraints * sizeof ( size_t ) ) ; sm_core_SmIntVector_create ( & delegate -> mHasAllVelocityDisabledEquations , delegate -> mNumConstraints , 0 ) ; memcpy ( sm_core_SmIntVector_nonConstValues ( & delegate -> mHasAllVelocityDisabledEquations ) , hasAllVelocityDisabledEquations , delegate -> mNumConstraints * sizeof ( int32_T ) ) ; sm_core_SmIntVector_create ( & delegate -> mRunTimeEnabledEquations , delegate -> mNumAllConstraintEquations , 0 ) ; memcpy ( sm_core_SmIntVector_nonConstValues ( & delegate -> mRunTimeEnabledEquations ) , runtimeEnabledEquations , delegate -> mNumAllConstraintEquations * sizeof ( int32_T ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mDofToVelSlot , delegate -> mDof , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mDofToVelSlot ) , dofToVelSlot , delegate -> mDof * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mConstraintDofs , 0 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mConstraintDofs ) , constraintDofs , 0 * sizeof ( size_t ) ) ; sm_core_SmSizeTVector_create ( & delegate -> mConstraintDofOffsets , delegate -> mNumConstraints + 1 , 0 ) ; memcpy ( sm_core_SmSizeTVector_nonConstValues ( & delegate -> mConstraintDofOffsets ) , constraintDofOffsets , ( delegate -> mNumConstraints + 1 ) * sizeof ( size_t ) ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosDesired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosSuggested , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosNonRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mPosSuggAndFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelDesired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelSuggested , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelNonRequired , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mVelSuggAndFree , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mConstraintFilter , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveConstraints , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveDofs , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mActiveDofs0 , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mNewConstraints , 0 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mNewDofs , 6 ) ; sm_core_SmBoundedSet_create ( & scratchpad -> mUnsatisfiedConstraints , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mActiveConstraintsVect , 0 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mActiveDofsVect , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mFullDofToActiveDof , 6 , 0 ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mPartiallyPosTargetedPrims , 6 , & zeroSizePair ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mPartiallyVelTargetedPrims , 6 , & zeroSizePair ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mPosPartialTypes , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mVelPartialTypes , 6 , 0 ) ; sm_core_SmSizeTVector_create ( & scratchpad -> mPartiallyActivePrims , 6 , 0 ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mBaseFrameVelOffsets , 0 , & zeroSizePair ) ; sm_core_SmSizePairVector_create ( & scratchpad -> mCvQuaternionVelOffsets , 0 , & zeroSizePair ) ; sm_core_SmRealVector_create ( & scratchpad -> mCvQuaternionAzimuthValues , 0 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mInitialState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mStartState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mTestState , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mFullStateVector , 12 , 0.0 ) ; sm_core_SmIntVector_create ( & scratchpad -> mModeVector , 0 , 0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobianRowMaj , Jm * Jn , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobian , Jm * Jn , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mJacobianPrimSubmatrix , Jm * 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mConstraintNonhomoTerms , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mConstraintError , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mBestConstraintError , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mDeltas , Jn * ( Jm <= Jn ? Jm : Jn ) , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mSvdWork , 49 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchScaledDeltaVect , 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchTestStateVect , 12 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mLineSearchErrorVect , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mActiveDofVelsVect , 6 , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mVelSystemRhs , Jm , 0.0 ) ; sm_core_SmRealVector_create ( & scratchpad -> mMotionData , 78 , 0.0 ) ; delegate -> mSetTargets = NULL ; delegate -> mResetStateVector = Robot_d319c82e_49_resetSimStateVector ; delegate -> mInitializeTrackedAngleState = NULL ; delegate -> mComputeDiscreteState = NULL ; delegate -> mAdjustPosition = NULL ; delegate -> mPerturbJointPrimitiveState = Robot_d319c82e_49_perturbSimJointPrimitiveState ; delegate -> mPerturbFlexibleBodyState = Robot_d319c82e_49_perturbFlexibleBodyState ; delegate -> mComputePosDofBlendMatrix = NULL ; delegate -> mComputeVelDofBlendMatrix = NULL ; delegate -> mProjectPartiallyTargetedPos = NULL ; delegate -> mPropagateMotion = NULL ; delegate -> mComputeTransforms = NULL ; delegate -> mComputeAssemblyPosError = NULL ; delegate -> mComputeAssemblyJacobian = NULL ; delegate -> mComputeFullAssemblyJacobian = NULL ; delegate -> mIsInKinematicSingularity = NULL ; delegate -> mConvertStateVector = NULL ; delegate -> mConstructStateVector = Robot_d319c82e_49_constructStateVector ; delegate -> mExtractSolverStateVector = Robot_d319c82e_49_extractSolverStateVector ; delegate -> mExtractDiscreteStateVector = Robot_d319c82e_49_extractDiscreteStateVector ; delegate -> mIsPositionViolation = Robot_d319c82e_49_isPositionViolation ; delegate -> mIsVelocityViolation = Robot_d319c82e_49_isVelocityViolation ; delegate -> mProjectStateSim = Robot_d319c82e_49_projectStateSim ; delegate -> mComputeConstraintError = Robot_d319c82e_49_computeConstraintError ; delegate -> mResetModeVector = Robot_d319c82e_49_resetModeVector ; delegate -> mHasJointUpwardModeChange = Robot_d319c82e_49_hasJointUpwardModeChange ; delegate -> mPerformJointUpwardModeChange = Robot_d319c82e_49_performJointUpwardModeChange ; delegate -> mOnModeChangedCutJoints = Robot_d319c82e_49_onModeChangedCutJoints ; delegate -> mSetVariableModeJointsToLocked = Robot_d319c82e_49_setVariableModeJointsToLocked ; delegate -> mMech = NULL ; } static void initMechanismDelegates ( NeDaePrivateData * smData ) { PmAllocator * alloc = pm_default_allocator ( ) ; static const size_t motionInputOffsets [ 6 ] = { 0 , 1 , 2 , 3 , 4 , 5 } ; static const boolean_T * maybeLockedPrimHasModes = NULL ; static const size_t * maybeLockedPrimModeOffsets = NULL ; int_T status = 0 ; initAssemblyDelegate ( & smData -> mAssemblyDelegate ) ; initSimulationDelegate ( & smData -> mSimulationDelegate ) ; status = pm_create_size_vector_fields ( & smData -> mMotionInputOffsets , smData -> mNumMotionInputPrimitives , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mMotionInputOffsets . mX , motionInputOffsets , 6 * sizeof ( size_t ) ) ; status = pm_create_bool_vector_fields ( & smData -> mMaybeLockedPrimHasModes , smData -> mNumMaybeLockedPrimitives , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mMaybeLockedPrimHasModes . mX , maybeLockedPrimHasModes , 0 * sizeof ( boolean_T ) ) ; status = pm_create_size_vector_fields ( & smData -> mMaybeLockedPrimModeOffsets , smData -> mNumMaybeLockedPrimitives , alloc ) ; checkMemAllocStatus ( status ) ; memcpy ( smData -> mMaybeLockedPrimModeOffsets . mX , maybeLockedPrimModeOffsets , 0 * sizeof ( size_t ) ) ; } static void initComputationFcnPtrs ( NeDaePrivateData * smData ) { smData -> mSetParametersFcn = dae_cg_setParameters_function ; smData -> mPAssertFcn = dae_cg_pAssert_method ; smData -> mDerivativeFcn = dae_cg_deriv_method ; smData -> mNumJacPerturbLoBoundsFcn = dae_cg_numJacPerturbLoBounds_method ; smData -> mNumJacPerturbHiBoundsFcn = dae_cg_numJacPerturbHiBounds_method ; smData -> mOutputFcn = dae_cg_compOutputs_method ; smData -> mModeFcn = dae_cg_mode_method ; smData -> mZeroCrossingFcn = dae_cg_zeroCrossing_method ; smData -> mProjectionFcn = dae_cg_project_solve ; smData -> mCIC_MODE_Fcn = dae_cg_CIC_MODE_solve ; smData -> mCheckFcn = ( smData -> mStateVectorSize == 0 ) ? dae_cg_check_solve : NULL ; smData -> mAssemblyFcn = dae_cg_assemble_solve ; smData -> mSetupLoggerFcn = dae_cg_setupLoggerFcn ; smData -> mLogFcn = dae_cg_recordLog_method ; smData -> mResidualsFcn = NULL ; smData -> mLinearizeFcn = NULL ; smData -> mGenerateFcn = NULL ; } static void initLiveLinkToSm ( NeDaePrivateData * smData ) { smData -> mLiveSmLink = NULL ; smData -> mLiveSmLink_destroy = NULL ; smData -> mLiveSmLink_copy = NULL ; } void Robot_d319c82e_49_NeDaePrivateData_create ( NeDaePrivateData * smData ) { initBasicAttributes ( smData ) ; initStateVector ( smData ) ; initAsserts ( smData ) ; initModeVector ( smData ) ; initZeroCrossings ( smData ) ; initVariables ( smData ) ; initRuntimeParameters ( smData ) ; initIoInfo ( smData ) ; initInputDerivs ( smData ) ; initDirectFeedthrough ( smData ) ; initOutputDerivProc ( smData ) ; initMechanismDelegates ( smData ) ; initComputationFcnPtrs ( smData ) ; initLiveLinkToSm ( smData ) ; }
